import type { FrameSource, FrameSourceJSON } from "./Camera+Related";
import type { JSONType } from "./Common";
import type { DataCaptureContextListener } from "./DataCaptureContext+Related";
import type { DataCaptureContextSettingsJSON } from "./DataCaptureContextSettings";
import { DataCaptureContextSettings } from "./DataCaptureContextSettings";
import type { DataCaptureViewJSON } from "./DataCaptureView";
import type { FrameCapture } from "./private/CameraManager";
import type { Serializable } from "./private/Serializable";
import type { DataCaptureLoader } from "./worker/dataCaptureLoader";
import type { DataCaptureCallbackMessage, WorkerResponse } from "./worker/dataCaptureWorker+related";
export interface Change {
    type: "addControl" | "addOverlay" | "cameraSettings" | "frameSourceState" | "removeControl" | "removeOverlay" | "singleImageModeUploaderSettings" | "torchState" | "viewChange";
    newValue: any;
}
export declare type PrivateChangeSet = Change[];
export interface PrivateDataCaptureMode {
    type: "barcodeCapture" | "idCapture";
    _context: DataCaptureContext | null;
    attachedToContext: (context: DataCaptureContext) => void;
    detachedFromContext: () => void;
}
export interface DataCaptureMode extends Serializable {
    isEnabled(): boolean;
    setEnabled(enabled: boolean): Promise<void>;
    context: DataCaptureContext | null;
}
export interface DataCaptureModeJSON<S = JSONType> {
    type: "barcodeCapture" | "idCapture";
    enabled: boolean;
    settings: S;
}
export interface PrivateDataCaptureComponent {
    _context: DataCaptureContext;
}
export declare type DataCaptureComponentJSON = JSONType;
export interface DataCaptureComponent extends Serializable<DataCaptureComponentJSON> {
    readonly id: string;
}
export interface PrivateDataCaptureContextOptions {
    deviceName?: string | null;
    dataCaptureInstance?: DataCaptureLoader;
    delayedRegistration?: boolean;
    highEndBlurryRecognition?: boolean;
}
export interface PrivateDataCaptureContext {
    _frameSource?: FrameSource | null;
    modes: DataCaptureMode[];
    components: DataCaptureComponent[];
    initialize: () => Promise<void>;
    update: (changeSet?: PrivateChangeSet) => Promise<void>;
    addComponent: (component: DataCaptureComponent) => Promise<void>;
    dataCaptureInstance: DataCaptureLoader;
    sendFrameToProcessor: (capture: FrameCapture) => Promise<WorkerResponse<"processFrame">>;
    subscribeToWorkerMessages: (listener: (message: DataCaptureCallbackMessage) => void) => void;
    unsubscribeToWorkerMessages: (listener: (message: DataCaptureCallbackMessage) => void) => void;
    hasEnabledMode: () => boolean;
    new (licenseKey: string, options: PrivateDataCaptureContextOptions): DataCaptureContext;
}
export interface DataCaptureContextCreationOptions {
    deviceName?: string;
    licenseKey?: string;
    settings?: DataCaptureContextSettings;
}
interface RuntimeEnvironment {
    deviceOS: string;
    browser: string;
    browserVersion: string;
    deviceModelName: string;
}
export interface DataCaptureContextJSON extends RuntimeEnvironment {
    framework: string;
    settings: DataCaptureContextSettingsJSON;
    licenseKey: string;
    deviceName: string;
    frameSource: FrameSourceJSON | null;
    modes: DataCaptureModeJSON[];
    components: DataCaptureComponentJSON[];
    view: DataCaptureViewJSON | null;
}
export declare type PrivateFrameHandler = (frame: FrameCapture) => Promise<void>;
export declare class DataCaptureContext implements Serializable<DataCaptureContextJSON> {
    static deviceID: string;
    private readonly framework;
    private readonly runtimeEnvironment;
    private settings;
    private readonly licenseKey;
    private readonly deviceName;
    private _frameSource;
    private _view;
    private readonly modes;
    private readonly components;
    private readonly listeners;
    private readonly cameraPropertiesReportListener;
    private readonly cameraAccessErrorListener;
    private readonly onWorkerMessageListener;
    private readonly dataCaptureInstance;
    private readonly delayedRegistration;
    private readonly highEndBlurryRecognition;
    private readonly _frameHandlers;
    private constructor();
    get frameSource(): FrameSource | null;
    static create(): Promise<DataCaptureContext>;
    static createWithOptions(options: DataCaptureContextCreationOptions): Promise<DataCaptureContext>;
    /**
     * Disconnect the current frame source from the context and connect the new one. This process can happen multiple
     * times for the same frame source because of its initialisation (The mirroring info of a camera is only available
     * when it has started for example).
     * Trigger the "didChangeFrameSource" listeners only if the new frame source is different than the old one.
     */
    setFrameSource(frameSource: FrameSource | null): Promise<void>;
    addListener(listener: DataCaptureContextListener): void;
    removeListener(listener: DataCaptureContextListener): void;
    addMode(mode: DataCaptureMode): Promise<void>;
    removeMode(mode: DataCaptureMode): Promise<void>;
    removeAllModes(): Promise<void>;
    dispose(): Promise<void>;
    applySettings(settings: DataCaptureContextSettings): Promise<void>;
    toJSONObject(): DataCaptureContextJSON;
    private getView;
    private setView;
    private initialize;
    private get workerCommand();
    private requestFrameData;
    private sendFrameToProcessor;
    private sendFrameToSDC;
    private registerFrameHandler;
    private unregisterFrameHandler;
    private onWorkerMessage;
    private subscribeToCameraManagerEvents;
    private reportCameraProperties;
    private onCameraAccessError;
    private update;
    private updateContext;
    private getViewWidthAndHeight;
    private getMirrorAxisForFrameSource;
    private addComponent;
    private subscribeToWorkerMessages;
    private unsubscribeToWorkerMessages;
    private hasEnabledMode;
}
export {};
