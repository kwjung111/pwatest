import { DataCaptureEngine } from "./dataCaptureEngine";
import type { AnyDataCaptureActionMessage, DataCaptureActionMessageKey, DataCaptureCallbackMessage, Module, WorkerResponse } from "./dataCaptureWorker+related";
declare type AugmentedWorker<M extends Module> = Worker & {
    Module: M;
    OffscreenCanvas: new (w: number, h: number) => OffscreenCanvas;
};
export declare type EngineWorkerResponse<C extends DataCaptureActionMessageKey> = WorkerResponse<C> extends Promise<void> | void ? Promise<void> | void : {
    payload: WorkerResponse<C>;
    transferables?: Transferable[];
};
declare const workerPathOrURLContent = "js/worker.js";
export default workerPathOrURLContent;
export interface ModuleHandler<M extends Module> {
    get: () => M;
    set: (v: M) => void;
}
export declare class WorkerMain<E extends DataCaptureEngine<M>, M extends Module> {
    dataCaptureInstance: E;
    private readonly workerSelf;
    constructor(workerSelf: AugmentedWorker<M>, module: ModuleHandler<M>);
    listenToMessages(): void;
    postMessage(message: DataCaptureCallbackMessage, transfer?: Transferable[]): void;
    getOffscreenCanvas(): OffscreenCanvas | undefined;
    hasPayload(result: unknown): result is {
        payload: unknown;
    };
    hasTransferables(result: unknown): result is {
        transferables: Transferable[];
    };
    respondWith<C extends DataCaptureActionMessageKey>(command: C, requestId: number, executor: () => EngineWorkerResponse<C>): Promise<void>;
    /**
     * Messages received from the main thread (actions to undertake)
     */
    onMessage(event: MessageEvent<AnyDataCaptureActionMessage>): boolean;
}
declare const workerInstance: WorkerMain<DataCaptureEngine<Module>, Module>;
export { workerInstance };
