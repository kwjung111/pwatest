import type { DataCaptureContextJSON, PrivateLoadableFrameData } from "..";
import type { EngineWorkerResponse, ModuleHandler } from "./dataCapture.worker";
import type { DataCaptureCallbackMessage, DataCaptureContext, DataCaptureContextDeserializer, DataCaptureImageBufferFrameSource, DataCaptureView, Module, Vector, WasmFrameData } from "./dataCaptureWorker+related";
import { PrivateMirrorAxis } from "../DataCaptureContext+Related";
import type { ProgressInfo } from "../LoadingStatus";
import type { Commands } from "../typings/vgCommandContext";
export interface LoadLibraryParameters {
    libraryLocation: string;
    locationPath: string;
    preloadEngine: boolean;
    writableDataPathOverride?: string;
    onProgress?: (info: ProgressInfo) => void;
}
export interface CreateContextParameters {
    context: DataCaptureContextJSON;
    deviceId: string;
    domain: string;
    delayedRegistration: boolean;
    highEndBlurryRecognition: boolean;
}
export interface UpdateContextParameters {
    context: DataCaptureContextJSON;
    view: {
        width: number;
        height: number;
    } | null;
}
export interface SetFrameSourceParameters {
    mirrorAxis: PrivateMirrorAxis;
}
export interface ProcessFrameParameters {
    data: Uint8ClampedArray;
    width: number;
    height: number;
}
export interface ReportCameraPropertiesParameters {
    deviceId: string;
    isFrontFacing: boolean;
    hasAutofocus: boolean;
}
export interface WorkerFunctions {
    postMessage: (message: DataCaptureCallbackMessage, transfer?: Transferable[]) => void;
    getOffscreenCanvas: () => OffscreenCanvas | undefined;
}
/**
 * DataCaptureEngine is an abstraction of the engine, it is created by the engine worker
 * and should be used as a singleton. It calls the underlying engine methods directly.
 */
export declare class DataCaptureEngine<M extends Module> {
    lastUsedModuleMirrorAxis: unknown;
    context: DataCaptureContext;
    protected readonly MAX_NUMBER_OF_IMAGES_IN_FRAME_DATA_POOL: number;
    protected libraryLoadingPromise: Promise<void> | undefined;
    protected writableDataPath: string;
    protected resourcePath: string;
    protected _isDrawLoopRunning: boolean;
    protected readonly redrawInterval: number;
    protected readonly redrawRequests: number[];
    protected loopTimeoutId?: ReturnType<typeof setTimeout>;
    protected contextDeserializer: DataCaptureContextDeserializer | undefined;
    protected imageFrameSource?: DataCaptureImageBufferFrameSource;
    protected view: DataCaptureView | undefined;
    protected lastFrameCounter: number;
    protected frameDataPool: Map<number, Uint8ClampedArray>;
    protected readonly moduleHandler: ModuleHandler<M>;
    protected readonly workerFunctions: WorkerFunctions;
    constructor(moduleHandler: ModuleHandler<M>, workerFunctions: WorkerFunctions);
    private _loadProgressCallback;
    get Module(): M;
    loadLibrary(parameters: LoadLibraryParameters): EngineWorkerResponse<"loadLibrary">;
    createContext(createContextJSON: CreateContextParameters): EngineWorkerResponse<"createContext">;
    getModeDeserializers(): Vector;
    setFrameSource(mirrorAxis: PrivateMirrorAxis): EngineWorkerResponse<"setFrameSource">;
    processFrame(parameters: ProcessFrameParameters): EngineWorkerResponse<"processFrame">;
    updateContext(contextUpdateParameters: UpdateContextParameters): EngineWorkerResponse<"updateContext">;
    reportCameraProperties(properties: ReportCameraPropertiesParameters): EngineWorkerResponse<"reportCameraProperties">;
    dispose(): EngineWorkerResponse<"dispose">;
    extractCentaurusLicense(scanditLicenseKey: string): EngineWorkerResponse<"extractCentaurusLicense">;
    convertToLoadableFrameData(frameData: WasmFrameData): PrivateLoadableFrameData;
    requestFrameData(frameId: number): EngineWorkerResponse<"requestFrameData">;
    deleteFrameData(frameId: number): void;
    protected getNextFrameId(): number;
    private setView;
    private contextDidChangeStatus;
    private didStartObservingContext;
    private setViewRefreshHandler;
    scheduleRedraw(view: DataCaptureView, redrawInMs: number): void;
    get isDrawLoopRunning(): boolean;
    set isDrawLoopRunning(newValue: boolean);
    /**
     * Redraw requests are scheduled at [now + redrawInMs], so when pushed they must be sorted
     * in chronological order so that we can later easily check if we need to redraw by checking
     * the first element.
     * @param redrawInMs
     */
    private addRedrawRequest;
    /**
     * The draw loop check at regular interval if any redraw request were made by the engine.
     * If a redraw is necessary, it gathers and sends drawing commands to the main thread.
     */
    startDrawLoop(view: DataCaptureView): void;
    sendViewRefreshCommands(commands: Commands[]): void;
    protected getWasmDynamicLibraries(coreWasmURI: string): string[];
    protected getWasmCoreExpectedHash(simdSupport: boolean): string;
    protected getWasmCoreFileName(simdSupport: boolean): string;
    protected getWasmSideModuleFileName(): string;
    private setup;
    private mapMirrorAxisOnModule;
}
