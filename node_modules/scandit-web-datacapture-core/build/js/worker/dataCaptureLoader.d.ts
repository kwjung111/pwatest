import type { WorkerResponse } from "./dataCaptureWorker+related";
import type { AnyDataCaptureActionMessage, DataCaptureActionMessageKey, DataCaptureCallbackMessage, DataCaptureWorker } from ".";
import type { ProgressInfo } from "../LoadingStatus";
import { Logger } from "../logger";
declare type CommandAndPayload<A, C> = A extends {
    command: C;
} ? A : never;
declare type WorkerCommandPayload<C> = Omit<CommandAndPayload<AnyDataCaptureActionMessage, C>, "command" | "id">;
declare type WorkerListener = (event: DataCaptureCallbackMessage) => any;
export interface DataCaptureLoaderOptions {
    libraryLocation: string;
    preloadEngine?: boolean;
    loadProgressNotifier?: (info: ProgressInfo) => void;
    logLevel?: Logger.Level;
}
/**
 * The DataCaptureLoader class is used by the main thread, it instantiates the worker
 * and sends commands to it. It represents thus the main communication channel
 * between the main thread and the engine running in the worker.
 */
export declare class DataCaptureLoader {
    protected _dataCaptureWorker?: DataCaptureWorker | undefined;
    protected readonly libraryLocation: string;
    /**
     * Mainly useful for FS when merging preloaded data (blurry tables preloading).
     */
    protected readonly isPreloadEngine: boolean;
    protected workerCommandId: number;
    protected readonly workerTasks: Map<number, {
        resolve: (...arguments_: any[]) => any;
        reject: (...arguments_: any[]) => any;
        command: string;
    }>;
    protected readonly workerListeners: WorkerListener[];
    workerMessageListener: (event_: MessageEvent<DataCaptureCallbackMessage>) => void;
    protected constructor(libraryLocation: string, isPreloadEngine: boolean, loadProgressNotifier?: DataCaptureLoaderOptions["loadProgressNotifier"]);
    static create(options: DataCaptureLoaderOptions): Promise<DataCaptureLoader>;
    load(): Promise<WorkerResponse<"loadLibrary">>;
    /**
     * Send a task (i.e. a command) to the worker. Every task sent has a corresponding Promise object which
     * gets resolved when the worker has processed the request. The tasks are identified by an id which is
     * sent along with the data by both sides.
     */
    workerCommand<C extends DataCaptureActionMessageKey>(command: C, payload: WorkerCommandPayload<C>, transferables?: Transferable[]): Promise<WorkerResponse<C>>;
    get dataCaptureWorker(): DataCaptureWorker;
    terminateDataCaptureWorker(disposeContext?: boolean): Promise<void>;
    addWorkerListener(listener: WorkerListener): void;
    removeWorkerListener(listener: WorkerListener): void;
    protected onWorkerMessage(event_: MessageEvent<DataCaptureCallbackMessage>): void;
}
export {};
