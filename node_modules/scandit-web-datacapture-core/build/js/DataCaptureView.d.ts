import type { MarginsWithUnit, MarginsWithUnitJSON, PointWithUnit, PointWithUnitJSON } from "./Common";
import { Orientation, Point, Quadrilateral, Size } from "./Common";
import type { DataCaptureContext } from "./DataCaptureContext";
import type { FocusGesture, FocusGestureJSON, LogoStyle, ZoomGesture, ZoomGestureJSON } from "./DataCaptureView+Related";
import type { Serializable } from "./private/Serializable";
import type { Control } from ".";
export interface DataCaptureOverlay extends Serializable {
    toJSONObject: () => any;
}
export interface DataCaptureViewListener {
    didChangeSize?: (view: DataCaptureView, size: Size, orientation: Orientation) => void;
}
export declare enum Anchor {
    TopLeft = "topLeft",
    TopCenter = "topCenter",
    TopRight = "topRight",
    CenterLeft = "centerLeft",
    Center = "center",
    CenterRight = "centerRight",
    BottomLeft = "bottomLeft",
    BottomCenter = "bottomCenter",
    BottomRight = "bottomRight"
}
export interface DataCaptureViewJSON {
    scanAreaMargins: MarginsWithUnitJSON;
    pointOfInterest: PointWithUnitJSON;
    logoAnchor: Anchor;
    logoOffset: PointWithUnitJSON;
    logoHidden: boolean;
    logoStyle: LogoStyle;
    overlays: any[];
    controls: any[];
    focusGesture: FocusGestureJSON | null;
    zoomGesture: ZoomGestureJSON | null;
}
export declare class DataCaptureView implements Serializable<DataCaptureViewJSON> {
    static CONTAINER_CLASS_NAME: string;
    static PAINTBOARD_CLASS_NAME: string;
    static PAINTBOARD_CLASS_NAME_STATE_ON: string;
    static CONTROLS_CLASS_NAME: string;
    static CONTROL_WIDGET_CLASS_NAME: string;
    static MIRRORED_CLASS_NAME: string;
    static CAMERA_RECOVERY_CLASS_NAME: string;
    static ERROR_CLASS_NAME: string;
    static PAINTBOARDS_CONTAINER_CLASS_NAME: string;
    static SINGLE_IMAGE_UPLOADER_CONTAINER_CLASS_NAME: string;
    static CANVAS_VIDEO_PREVIEW_CLASS_NAME: string;
    private _onInputFileChange;
    private _inputCheckFunction;
    private _scanAreaMargins;
    private _pointOfInterest;
    private _logoStyle;
    private _logoAnchor;
    private _logoOffset;
    focusGesture: FocusGesture | null;
    zoomGesture: ZoomGesture | null;
    private _cameraRecoveryText;
    private _context;
    private readonly overlays;
    private readonly controls;
    private readonly controlWidgets;
    private containerElement;
    private cameraPaintboardElement?;
    private singleImageUploaderPaintboardElement?;
    private videoElement?;
    private visibilityListener;
    private videoPauseListener;
    private cameraRecoveryListener;
    private controlsElement;
    private cameraRecoveryElement;
    private errorElement;
    private canvasElement;
    private _canvasDrawer;
    private readonly listeners;
    private htmlElement?;
    private htmlElementState?;
    private lastHtmlElementState;
    private isVideoElementDetached;
    private progressBarView;
    private lastFrameSourceState;
    constructor();
    get scanAreaMargins(): MarginsWithUnit;
    set scanAreaMargins(margins: MarginsWithUnit);
    get pointOfInterest(): PointWithUnit;
    set pointOfInterest(pointOfInterest: PointWithUnit);
    get logoStyle(): LogoStyle;
    set logoStyle(logoStyle: LogoStyle);
    get logoAnchor(): Anchor;
    set logoAnchor(logoAnchor: Anchor);
    get logoOffset(): PointWithUnit;
    set logoOffset(logoOffset: PointWithUnit);
    get cameraRecoveryText(): string;
    set cameraRecoveryText(cameraRecoveryText: string);
    showProgressBar(): void;
    hideProgressBar(): void;
    setProgressBarPercentage(percentage: number | null): void;
    setProgressBarMessage(message: string): void;
    private get width();
    private get height();
    private get canvasDrawer();
    /**
     * The current context as a PrivateDataCaptureContext
     */
    private get privateContext();
    static forContext(context: DataCaptureContext | null): Promise<DataCaptureView>;
    getContext(): DataCaptureContext | null;
    setContext(context: DataCaptureContext | null): Promise<void>;
    connectToElement(element: HTMLElement): void;
    addOverlay(overlay: DataCaptureOverlay): Promise<void>;
    removeOverlay(overlay: DataCaptureOverlay): Promise<void>;
    addListener(listener: DataCaptureViewListener): void;
    removeListener(listener: DataCaptureViewListener): void;
    /**
     * Converts a point in the coordinate system of the last visible frame and maps it to a coordinate in the view.
     * It does *not* take into account if the frameSource is mirrored.
     */
    viewPointForFramePoint(point: Point): Point;
    viewQuadrilateralForFrameQuadrilateral(quadrilateral: Quadrilateral): Quadrilateral;
    addControl(control: Control): void;
    removeControl(control: Control): void;
    toJSONObject(): DataCaptureViewJSON;
    isCameraRecoveryVisible(): boolean;
    setCameraRecoveryVisible(visible: boolean): void;
    private setupHtmlElement;
    private setupHtmlElementSingleImageUploaderChildren;
    private setupHtmlElementVisibility;
    private createStyles;
    private htmlElementDidChange;
    private htmlElementDisconnected;
    private handleVideoDisplay;
    private onWorkerMessage;
    private drawEngineCommands;
    private displayError;
    private clearError;
    private controlsUpdated;
    private redrawControls;
    private getControlWidget;
    private onFrameSourceChange;
    private setVideoElementOpacity;
    private onSingleImageUploaderSettingsChange;
    private handleVideoPause;
    private checkAndRecoverPlayback;
    private cameraRecovery;
    /**
     * Update width and height *attributes* according to video DOM size.
     */
    private updateCanvasSizeAttributes;
}
