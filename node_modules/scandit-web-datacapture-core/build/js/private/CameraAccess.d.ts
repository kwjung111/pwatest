import type { VideoFrameResolution } from "../Camera";
export declare enum CameraPosition {
    WorldFacing = "worldFacing",
    UserFacing = "userFacing"
}
export declare enum CameraResolutionConstraint {
    ULTRA_HD = 0,
    FULL_HD = 1,
    HD = 2,
    SD = 3,
    NONE = 4
}
export declare enum AspectRatio {
    AUTO = "auto",
    FOUR_TO_THREE = "fourToThree",
    SIXTEEN_TO_NINE = "sixteenToNine"
}
export interface DeviceCamera {
    position: CameraPosition;
    label: string;
    deviceId: string;
    currentResolution?: VideoFrameResolution;
}
/**
 * A helper object to interact with cameras.
 */
export declare namespace CameraAccess {
    /**
     * @hidden
     *
     * Overrides for main camera for a given camera position on a desktop/laptop device, set when accessing an initial camera.
     */
    const mainCameraForPositionOverridesOnDesktop: Map<CameraPosition, DeviceCamera>;
    /**
     * @hidden
     *
     * To be accessed directly only for tests.
     *
     * The mapping from deviceIds to camera objects.
     */
    const deviceIdToCameraObjects: Map<string, DeviceCamera>;
    /**
     * @hidden
     *
     * To be accessed directly only for tests.
     *
     * The list of inaccessible deviceIds.
     */
    const inaccessibleDeviceIds: Set<string>;
    /**
     * @hidden
     *
     * @param label The camera label.
     * @returns Whether the label identifies the camera being the iOS Wide front (main) camera one.
     */
    function isIOSWideFrontCameraLabel(label: string): boolean;
    /**
     * @hidden
     *
     * @param label The camera label.
     * @returns Whether the label identifies the camera being the iOS Wide back (main) camera one.
     */
    function isIOSWideBackCameraLabel(label: string): boolean;
    /**
     * @hidden
     *
     * @param label The camera label.
     * @returns Whether the label identifies the camera being the iOS UltraWide back camera one.
     */
    function isIOSUltraWideBackCameraLabel(label: string): boolean;
    /**
     * @hidden
     *
     * Get the main camera for the given camera position.
     *
     * @param cameras The array of available [[DeviceCamera]] objects.
     * @param cameraPosition The wanted camera position.
     * @returns The main camera matching the wanted camera position.
     */
    function getMainCameraForPosition(cameras: DeviceCamera[], cameraPosition: CameraPosition): DeviceCamera | undefined;
    /**
     * @hidden
     *
     * Sort the given cameras in order of priority of access based on the given camera position.
     *
     * @param cameras The array of available [[DeviceCamera]] objects.
     * @param cameraPosition The preferred camera position.
     * @returns The sorted cameras.
     */
    function sortCamerasForCameraPosition<DeviceCameraLike extends DeviceCamera = DeviceCamera>(cameras: DeviceCameraLike[], cameraPosition: CameraPosition): DeviceCameraLike[];
    /**
     * @hidden
     *
     * Adjusts the camera's information based on the given currently active video stream.
     *
     * @param mediaStream The currently active `MediaStream` object.
     * @param camera The currently active [[Camera]] object associated with the video stream.
     */
    function adjustCameraFromMediaStream(mediaStream: MediaStream, camera: DeviceCamera): void;
    /**
     * Get a list of cameras (if any) available on the device, a camera access permission is requested to the user
     * the first time this method is called if needed.
     *
     * If the browser is incompatible the returned promise is rejected with a `UnsupportedBrowserError` error.
     *
     * When refreshing available devices, if updated deviceId information is detected, cameras' deviceId are updated
     * accordingly. This could happen after a camera access and stop in some situations.
     *
     * @param refreshDevices Force a call to refresh available video devices even when information is already available.
     * @param cameraAlreadyAccessed Hint that a camera has already been accessed before, avoiding a possible initial
     * camera access permission request on the first call, in cases this cannot be already reliably detected.
     * @returns A promise resolving to the array of available [[Camera]] objects (could be empty).
     */
    function getCameras(refreshDevices?: boolean, cameraAlreadyAccessed?: boolean): Promise<DeviceCamera[]>;
    /**
     * @hidden
     *
     * Get the *getUserMedia* *video* parameters to be used given a resolution fallback level and the browser used.
     *
     * @param cameraResolutionConstraint The resolution constraint.
     * @returns The resulting *getUserMedia* *video* parameters.
     */
    function getUserMediaVideoParameters(cameraResolutionConstraint: CameraResolutionConstraint, preferredAspectRatio?: AspectRatio): MediaTrackConstraints;
    /**
     * @hidden
     *
     * Try to access a given camera for video input at the given resolution level.
     *
     * If a camera is inaccessible because of errors, then it's added to the inaccessible device list. If the specific
     * error is of type `OverconstrainedError` or `NotReadableError` however, this procedure is done later on via a
     * separate external logic; also, in case of an error of type `NotAllowedError` (permission denied) this procedure is
     * not executed, in order to possibly recover if and when the user allows the camera to be accessed again.
     * This is done to allow checking if the camera can still be accessed via an updated deviceId when deviceId
     * information changes, or if it should then be confirmed to be considered inaccessible.
     *
     * Depending on parameters, device features and user permissions for camera access, any of the following errors
     * could be the rejected result of the returned promise:
     * - `AbortError`
     * - `NotAllowedError`
     * - `NotFoundError`
     * - `NotReadableError`
     * - `SecurityError`
     * - `OverconstrainedError`
     *
     * @param cameraResolutionConstraint The resolution constraint.
     * @param camera The camera to try to access for video input.
     * @returns A promise resolving to the `MediaStream` object coming from the accessed camera.
     */
    function accessCameraStream(camera: DeviceCamera, cameraResolutionConstraint: CameraResolutionConstraint, preferredAspectRatio?: AspectRatio): Promise<MediaStream>;
    /**
     * @hidden
     *
     * Mark a camera to be inaccessible and thus excluded from the camera list returned by [[getCameras]].
     *
     * @param camera The camera to mark to be inaccessible.
     */
    function markCameraAsInaccessible(camera: DeviceCamera): void;
}
